# 테스팅

- https://docs.nestjs.com/fundamentals/testing

- 자동화된 테스트는 중요한 소프트웨어 개발의 노력에서 필수적인 부분으로 고려된다.
- 자동화는 개별 테스트를 반복적으로 테스트하기 쉽게하며 또는 개발중에 테스트 모음을 빠르게하고 쉽게한다.
- 자동화는 출시의 품질과 성능적인 목표를 보증하게 할 수 있다.
- 자동화는 코드 커버리지와 개발자들에게 빠른 피드백을 보여줄 수 있다.
- 자동화는 각각의 개발자들의 생산성과 테스트들이 중요한 개발 수행의 한 지점, 예를 들어 있는 소스 코드 점검이나, 기능 통합, 또는 버전 출시에 있어서 보증할 수 있다.

## Nest 에서 테스트를 위해 제공하는 기능들

- 이러한 테스트들은 종종 다양한 테스트들로 확장된다, 유닛 테스트, e2e 테스트, 통합테스트 등등.
- 효용성은 물어볼것도 없지만, 테스트를 설정하는 것은 지루할 수 있다.
- Nest는 효율적인 테스팅을 포함하여 개발의 제일 좋은 방법을 촉진하기 위해 애쓰고 있다, 그리하여 개발자와 팀들에게 자동화 테스트를 빌드하는 법을 다음과 같이 포함하고 있다.

1. 애플리케이션의 컴포넌트와 e2e 테스트를 위한 기본적인 유닛테스트를 자동으로 만들 수 있다.
2. 기본적인 도구를 제공한다 (격리된 모듈/애플리케이션 로더를 빌드 할 수 있는 테스트 러너)
3. `Jest`와 `Supertest`를 설치 없이 통합 제공.
4. 컴포넌트 목업을 만들기 위해 테스트 환경에서 Nest 의존성 주입 시스템을 사용할 수 있다.

- 언급한대로, 당신이 좋아하는 어떠한 테스트 프레임워크도 사용할 수 있다, Nest는 어떠한 도구를 특정하여 강제하지 않는다.
- 간단하게 테스트러너와 같은 요소를 필요한 것으로 대체할 수 있고, Nest가 제공하는 이미 만들어진 테스트 기능을 여전히 즐길 수 있다!

## 설치

- 시작하기 위해, 먼저 필요한 패키지를 설치하자:

```Typescript
$ npm i --save-dev @nesatjs/testing
```

## 유닛 테스트

- 아래의 예제를 따라하기 위해, `CatsController`와 `CatsService`를 테스트 해보자.
- 언급한대로, `Jest`가 기본 테스트 프레임워크로 제공된다.
- `Jest`는 테스트 러너와 단언 함수 그리고 모킹, 스파이 등을 활용할 수 있다.
- 아래의 기본 테스트에서, 우리는 수동으로 클래스들을 인스턴스화 하고, 컨트롤러와 서비스가 API 호출 할 수 있게 한다.

```Typescript
import { CatsController } from './cats.controller';
import { CatsService } from './cat.service';

describe('CatsController', () => {
    let catsController: CatsController;
    let catsService: CatsService;

    beforEach(() => {
        catsService = new CatsService();
        catsController = new CatsController(catsService);
    });

    describe('findAll', () => {
        it('should return an array of cats', async () => {
            const result = ['test'];
            jest.spyOn(catsService, 'findAll').mockImplementation(() => result);

            expect(await catsController.findAll()).toBe(result);
        });
    });
})
```

```
힌트

테스트 파일을 테스트하려는 클래스 근처에 두자.
테스팅 파일은 `.spec` 또는 `.test`의 접미사를 가져아 한다.
```

- 위의 예제는 진부하기 떄문에, 우리는 Nest 테스트 특정 기능을 하나도 사용하지 않았다.
- 실제로 우리는 의존성 주입마저 사용하지 않았다. (우리는 `CatsService` 인스턴스를 `CatsController`에 전달하였음을 확인하자.)
- 이러한 형식의 테스팅 ~ 우리가 수동으로 테스트하려는 클래스를 인스턴스화 하는 ~ 종종 격리된 테스팅이라고 불린다 왜냐면 프레임워크에 독립적이기 때문이다.
- 고급 활용법을 소개하고 우리의 테스트 애플리케이션을 Nest 기법을 사용하여 좀 더 값지게 만들어보자.

## 테스팅 유틸리티

- `@nestjs/testing` 패키지는 유틸리티 모음을 제공하여 보다 견고한 테스트 동작을 가능하게 한다.
- 이전의 예제를 제공된 `Test` 클래스를 사용하여 다시 써보자:

```Typescript
import { Test } from '@nestjs/testing';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

describe('CatsController', () => {
    let catsController: CatsController;
    let catsService: CatsService;

    beforEach(async () => {
        const moduleRef = await Test.createTestingModule({
            controllers: [CatsController],
            providers: [CatsService],
        }).compile();

        catsService = moduleRef.get<CatsService>(CatsService);
        catsController = moduleRef.get<CatsController>(CatsController);
    });

    describe('findAll', () => {
        it('should return an array of cats', async () => {
            const result = ['test'];
            jest.spyOn(catsService, 'findAll').mockImplementation(() => result);

            expect(await catsController.findAll()).toBe(result);
        })
    })
})
```
